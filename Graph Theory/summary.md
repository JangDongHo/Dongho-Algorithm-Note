# 이미 배운 내용을 훑어보자

- 그래프 알고리즘은 굉장히 다양한데, 코딩 테스트에서 출제 비중이 낮은 편이지만 꼭 제대로 알야아 하는 알고리즘이다.
- 알고리즘 문제를 접했을 때 '서로 다른 개체가 연결되어 있다'는 조건이 있으면 그래프 알고리즘을 의심해보자.

  - ex. '여러 개의 도시가 연결되어 있다'

|               |             그래프             |         트리          |
| :-----------: | :----------------------------: | :-------------------: |
|    방향성     | 방향 그래프 혹은 무방향 그래프 |      방향 그래프      |
|    순환성     |         순환 및 비순환         |        비순환         |
|   루트 노드   |         루트 노드 없음         |    루트 노드 존재     |
| 노드간 관계성 |     부모와 자식 관계 없음      | 부모와 자식 관계 존재 |
|  모델의 종류  |         네트워크 모델          |       계층 모델       |

- 그래프의 구현 방법

  1. 인접 행렬 : 2차원 배열로 그래프의 연결 관계를 표현하는 방식
  2. 인접 리스트 : 리스트로 그래프의 연결 관계를 표현하는 방식

- 9장에서 우선순위 큐를 이용하는 다익스트라 알고리즘은 인전 리스트를 이용하는 방식이다.
  - 노드의 개수 V개일 때는 V개의 리스트를 만들어서 각 노드와 연결된 노드에 대한 정보를 저장하는 방식이다.
- 플로이드 워셜 알고리즘은 인접 행렬을 이용하는 방식이다.

  - 모든 노드에서 다른 노드로 가는 최소 비용을 V^2개의 리스트에 저장하는 방식이다.

- 최단 경로를 찾아야 하는 문제가 생겼을 때, 노드의 개수가 적은 경우에는 플로이드 워셜 알고리즘을 사용하고, 노드의 개수가 많은 경우에는 다익스트라 알고리즘을 사용하는 것이 좋다.

# 기타 그래프 알고리즘

## 서로소 집합

- 서로소 집합 자료구조란 서로소 부분 집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조이다.
- 서로소 집합 자료구조는 두 종류의 연산을 지원한다.

  1. 합집합(Union) : 두 개의 원소가 포함된 집합을 하나의 집합으로 합치는 연산
  2. 찾기(Find) : 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산

### 서로소 집합 자료구조

- 서로소 집합 자료구조를 구현할 때는 트리 자료구조를 이용하여 집합을 표현한다.
- 알고리즘

  1. union (합집합) 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인한다

  - A와 B의 루트 노드 A', B'를 각각 찾는다.
  - A'를 B'의 부모 노드로 설정한다.

  1. 모든 union 연산을 처리할 때까지 1번 과정을 반복한다.

```python
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출한다.
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return x

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 노드의 개수와 간선(Union 연산)의 개수 입력 받기
v, e = map(int, input().split())
parent = [0] * (v + 1) # 부모 테이블 초기화하기

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i

# Union 연산을 각각 수행
for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent, a, b)

# 각 원소가 속한 집합 출력하기
print('각 원소가 속한 집합: ', end='')
for i in range(1, v + 1):
    print(find_parent(parent, i), end=' ')

print()

# 부모 테이블 내용 출력하기
print('부모 테이블: ', end='')
for i in range(1, v + 1):
    print(parent[i], end=' ')
```

> 입력

```
6 4
1 4
2 3
2 4
5 6
```

> 출력

```
각 원소가 속한 집합: 1 1 1 1 5 5
부모 테이블: 1 1 2 1 5 5
```

- 노드의 개수가 V개이고 find 혹은 union 연산의 개수가 M개일 때, 시간 복잡도는 O(VM)이 되어 비효율적이다.
- 경로 압축 기법을 사용하면 시간 복잡도를 개선할 수 있다.

### 경로 압축 기법

- 경로 압축은 find 함수를 재귀적으로 호출한 뒤에 부모 테이블 값을 바로 갱신한다.

```python
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]
```

### 서로소 집합 알고리즘의 시간 복잡도

- 경로 압축 기법을 사용하면 시간 복잡도는 O(V + M(1 + log_2M/V))가 된다.
- 예를 들어, 노드의 개수가 1,000개이고, union 연산 및 find 연산이 총 100만 번 수행된다고 하자.
  - 이 경우 1,000만 가량의 연산이 필요하다고 볼 수 있다.

### 서로소 집합을 활용한 사이클 판별

- 서로소 집합은 무방향 그래프 내에서의 사이클을 판별할 때 사용할 수 있다.
- 앞서 union 연산은 그래프에서의 간선으로 표현될 수 있다고 했다.
- 따라서, 간선을 하나씩 확인하면서 두 노드가 포함되어 있는 집합을 합치는 과정을 반복하는 것만으로도 사이클을 판별할 수 있다.
- 알고리즘

  1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.
     - 루트 노드가 서로 다르다면 두 노드에 대하여 union 연산을 수행한다.
     - 루트 노드가 서로 같다면 사이클(Cycle)이 발생한 것이다.
  2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복한다.

```python
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출한다.
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 노드의 개수와 간선(Union 연산)의 개수 입력 받기
v, e = map(int, input().split())
parent = [0] * (v + 1) # 부모 테이블 초기화하기

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i

cycle = False # 사이클 발생 여부

for i in range(e):
    a, b = map(int, input().split())
    # 사이클이 발생한 경우 종료
    if find_parent(parent, a) == find_parent(parent, b):
        cycle = True
        break
    # 사이클이 발생하지 않았다면 합집합(Union) 연산 수행
    else:
        union_parent(parent, a, b)

if cycle:
    print("사이클이 발생했습니다.")
else:
    print("사이클이 발생하지 않았습니다.")
```

> 입력

```
3 3
1 2
1 3
2 3
```

> 출력

```
사이클이 발생했습니다.
```

## 신장 트리(Spanning Tree)

- 신장 트리는 그래프 알고리즘 문제로 자주 출제되는 문제 유형이다.
- 신장 트리란 하나의 그래프가 있을 때 모든 노드를 포함하면서 사이클이 존재하지 않는 부분 그래프를 의미한다.
- 모든 노드가 포함되어 서로 연결되면서 사이클이 존재하지 않는다는 조건은 트리의 성립 조건이기도 하다.

### 크루스칼 알고리즘

- 우리는 다양한 문제 상황에서 가능한 한 최소한의 비용으로 신장 트리를 찾아야 할 때가 있다.
  - ex. N개의 도시가 존재하는 상황에서 두 도시 사이에 도로를 놓아 전체 도시가 서로 연결될 수 있게 도로를 설치하는 경우
- 신장 트리 중에서 최소 비용으로 만들 수 있는 신장 트리를 찾는 알고리즘을 최소 신장 트리 알고리즘이라고 한다.
  - 대표적인 최소 신장 트리 알고리즘으로는 크루스칼 알고리즘이 있다.
- 크루스칼 알고리즘은 그리디 알고리즘으로 분류된다.
  - 가장 적은 비용으로 모든 노드를 연결할 수 있다는 점에서 최소 신장 트리 알고리즘으로 분류됨
- 알고리즘
  1. 간선 데이터를 비용에 따라 오름차순으로 정렬한다.
  2. 간선을 하나씩 확인하여 현재의 간선이 사이클을 발생시키는지 확인한다.
     - 사이클이 발생하지 않는 경우 최소 신장 트리에 포함시킨다.
     - 사이클이 발생하는 경우 최소 신장 트리에 포함시키지 않는다.
  3. 모든 간선에 대하여 2번의 과정을 반복한다.
- 최소 신장 트리는 일종의 트리 자료구조이므로, 최종적으로 신장 트리에 포함되는 간선의 개수는 '노드의 개수 - 1'과 같다.

```python
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀적으로 호출한다.
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]

# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b

# 노드의 개수와 간선(Union 연산)의 개수 입력 받기
v, e = map(int, input().split())
parent = [0] * (v + 1) # 부모 테이블 초기화하기

# 모든 간선을 담을 리스트와, 최종 비용을 담을 변수
edges = []
result = 0

# 부모 테이블상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i

# 모든 간선에 대한 정보를 입력 받기
for _ in range(e):
    a, b, cost = map(int, input().split())
    # 비용순으로 정렬하기 위해서 튜플의 첫 번째 원소를 비용으로 설정
    edges.append((cost, a, b))

# 간선을 비용순으로 정렬
edges.sort()

# 간선을 하나씩 확인하며
for edge in edges:
    cost, a, b = edge
    # 사이클이 발생하지 않는 경우에만 집합에 포함
    if find_parent(parent, a) != find_parent(parent, b):
        union_parent(parent, a, b)
        result += cost

print(result)
```

> 입력

```
7 9
1 2 29
1 5 75
2 3 35
2 6 34
3 4 7
4 6 23
4 7 13
5 6 53
6 7 25
```

> 출력

```
159
```

- 시간 복잡도
  - 간선의 개수가 E개일 때, O(ElogE)의 시간 복잡도를 가진다.
  - 크루스칼 알고리즘에서 가장 많은 시간을 요구하는 곳은 간선을 정렬하는 작업이다.
  - 크루스칼 내부에서 사용되는 서로소 집합 알고리즘의 시간 복잡도는 정렬 알고리즘의 시간 복잡도보다 작으므로 무시할 수 있다.
