# 가장 빠르게 도달하는 방법

- 최단 경로 알고리즘: 가장 짧은 경로를 찾는 알고리즘
- 상황에 맞는 효율적인 알고리즘이 이미 정립되어 있음
  - 한 지점에서 다른 한 지점까지의 최단 경로
  - 모든 지점에서 다른 모든 지점까지의 최단 경로
- 이런 사례에 맞는 알고리즘을 알고 있으면 좋음
- 최단 경로 문제는 보통 그래프를 이용해 표현하는데 각 지점은 그래프에서 **노드**로 표현되고 지점 간 연결된 도로는 그래프에서 **간선**으로 표현됨
- 실제 코딩 테스트에서는 최단 경로를 모두 출력하는 문제보다는 단순히 최단 거리를 출력하도록 요구하는 문제가 많이 출제됨
- 컴퓨터공학과 학부 수준에서 배우는 최단 경로 알고리즘은 다익스트라 최단 경로 알고리즘, 플로이드 워셜 알고리즘, 벨만 포드 알고리즘 등이 있음
  - 이 책에서는 코딩 테스트에서 가장 많이 등장하는 유형인 다익스트라와 플로이드 워셜 알고리즘을 다룸

# 다익스트라 최단 경로 알고리즘

- 특정한 노드에서 출발하여 다른 모든 노드로 가는 최단 경로를 계산
- 다익스트라 최단 경로 알고리즘은 음의 간선이 없을 때 정상적으로 동작
  - 현실 세계의 도로(간선)은 음의 간선으로 표현되지 않음
- 다익스트라 최단 경로 알고리즘은 그리디 알고리즘으로 분류됨
  - 매 상황에서 가장 비용이 적은 노드를 선택해 임의의 과정을 반복하기 때문

## 알고리즘의 원리

1. 출발 노드를 설정
2. 최단 거리 테이블을 초기화
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신
5. 위 과정에서 3번과 4번을 반복

- '각 노드에 대한 현재까지의 최단 거리' 정보를 항상 1차원 리스트에 저장하며 리스트를 계속 갱신한다는 특징이 있음
- 매번 현재 처리하고 있는 노드를 기준으로 주변 간선을 확인
- 파이썬에서 최단 거리를 '무한'으로 설정할 때는 10억을 설정하는 것이 일반적임
  - 지수 표기법으로 1e9로도 표현 가능
  - 앞으로 소스코드에서 '무한'을 의미하는 값으로 int(1e9)를 이용할 것임
- 다익스트라 알고리즘이 진행되면서 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해할 수 있음

### 방법 1. 간단한 다익스트라 알고리즘

- 처음에 각 노드에 대한 최단 거리를 담는 1차원 리스트를 선언하고, 단계마다 '방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택'하기 위해 매 단계마다 1차원 리스트의 모든 원소를 확인(순차 탐색)함

```python
import sys
input = sys.stdin.readline
INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

# 노드의 개수, 간선의 개수를 입력받기
n, m = map(int, input().split())
# 시작 노드 번호를 입력받기
start = int(input())
# 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기
graph = [[] for i in range(n + 1)]
# 방문한 적이 있는지 체크하는 목적의 리스트를 만들기
visited = [False] * (n + 1)
# 최단 거리 테이블을 모두 무한으로 초기화
distance = [INF] * (n + 1)

# 모든 간선 정보를 입력받기
for _ in range(m):
    a, b, c = map(int, input().split())
    # a번 노드에서 b번 노드로 가는 비용이 c라는 의미
    graph[a].append((b, c))

# 방문하지 않은 노드 중에서, 가장 최단 거리가 짧은 노드의 번호를 반환
def get_smallest_node():
    min_value = INF
    index = 0 # 가장 최단 거리가 짧은 노드(인덱스)
    for i in range(1, n + 1):
        if distance[i] < min_value and not visited[i]:
            min_value = distance[i]
            index = i
    return index

def dijkstra(start):
    # 시작 노드에 대해서 초기화
    distance[start] = 0
    visited[start] = True
    for j in graph[start]:
        distance[j[0]] = j[1]
    # 시작 노드를 제외한 전체 n - 1개의 노드에 대해 반복
    for i in range(n - 1):
        # 현재 최단 거리가 가장 짧은 노드를 꺼내서, 방문 처리
        now = get_smallest_node()
        visited[now] = True
        # 현재 노드와 연결된 다른 노드를 확인
        for j in graph[now]:
            cost = distance[now] + j[1]
            # 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
            if cost < distance[j[0]]:
                distance[j[0]] = cost

# 다익스트라 알고리즘을 수행
dijkstra(start)

# 모든 노드로 가기 위한 최단 거리를 출력
for i in range(1, n + 1):
    # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
    if distance[i] == INF:
        print("INFINITY")
    # 도달할 수 있는 경우 거리를 출력
    else:
        print(distance[i])
```

> 입력

```plaintext
6 11
1
1 2 2
1 3 5
1 4 1
2 3 3
2 4 2
3 2 3
3 6 5
4 3 3
4 5 1
5 3 1
5 6 2
```

> 출력

```plaintext
0
2
3
1
2
4
```

- 다익스트라 알고리즘의 시간 복잡도는 O(V^2)이다.
  - V: 노드의 개수
  - 따라서 노드의 개수가 5,000개 이하라면 이 코드로 문제를 해결할 수 있음
  - 하지만 노드의 개수가 10,000개를 넘어가는 문제라면 이 코드로는 문제를 해결할 수 없음
- 노드의 개수 및 간선의 개수가 많은 상황에서는 개선된 다익스트라 알고리즘을 이용해야 함

### 방법 2. 개선된 다익스트라 알고리즘

- 간단한 다익스트라 알고리즘은 '최단 거리가 가장 짧은 노드'를 찾기 위해서, 매번 최단 거리 테이블을 선형적으로(모든 원소를 앞에서부터 하나씩) 탐색해야 했음
  - 이 과정에서만 O(V)의 시간이 소요됨
- 최단 거리가 가장 짧은 노드를 더욱 더 빠르게 찾기 위해서는 **힙(Heap) 자료구조**를 사용하면 좋음
  - 이 과정에서 선형 시간이 아닌 로그 시간이 걸림
- 힙 자료구조는 우선순위 큐를 구현하기 위하여 사용하는 자료구조 중 하나
  - 우선순위 큐: 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조
  - 대부분의 프로그래밍 언어에서는 우선순위 큐 라이브러리를 지원하기 때문에, 따로 힙을 구현하는 방법에 대해서는 다루지 않음
- 파이썬에서는 우선순위 큐가 필요할 때 PriorityQueue 혹은 heapq를 사용
  - 다만, PriorityQueue보다는 일반적으로 heapq가 더 빠르게 동작하기 때문에 heapq를 사용하는 것을 권장
- 파이썬 에서 우선순위 큐 라이브러리에 데이터의 묶음을 넣으면, 첫번째 원소를 기준으로 우선순위를 정한다.
  - 따라서 (거리, 노드 번호)의 형태로 우선순위 큐에 넣으면 거리를 기준으로 우선순위가 설정됨
- 또한 우선순위 큐를 구현할 때는 내부적으로 최소 힙 혹은 최대 힙을 이용하여 구현함
  - 최소 힙: 값이 낮은 데이터가 먼저 삭제되는 형태의 자료구조
  - 최대 힙: 값이 큰 데이터가 먼저 삭제되는 형태의 자료구조
  - 파이썬에서는 최소 힙 구조를 이용하며, heapq 라이브러리를 그대로 사용하면 됨
- 또한 최소 힙을 최대 힙처럼 사용하기 위해서 일부러 우선순위에 해당하는 값에 음수 부호(-)를 붙여서 넣었다가, 나중에 우선순위 큐에서 원소를 꺼낸 다음에 다시 음수 부호(-)를 붙여서 원래의 값으로 돌리는 방식을 사용함

  - 이러한 방식을 사용하면 파이썬에서 기본적으로 제공하는 최소 힙 기능을 최대 힙처럼 사용할 수 있음
  - 이러한 테크닉도 코딩 테스트 문제에서 자주 사용되므로, 알아두면 좋음

- 리스트 vs 힙
  | 우선순위 큐 구현 방식 | 삽입 시간 | 삭제 시간 |
  | :---: | :---: | :---: |
  | 리스트 | O(1) | O(N) |
  | 힙 | O(logN) | O(logN) |
  - 데이터의 개수가 N개일 때, 힙 자료구조에 N개의 데이터를 모두 넣은 뒤에 모든 데이터를 꺼내는 과정은 O(NlogN)이 소요됨
- 단순히 우선순위 큐를 이용해서 시작 노드로부터 '거리'가 짧은 순서대로 큐에서 나올 수 있도록 다익스트라 알고리즘을 작성하면 된다.
- 코드

  - 방법 1과 다르게 get_smallest_node() 함수가 필요 없음
  - '최단 거리가 가장 짧은 노드'를 선택하는 과정을 다익스트라 최단 경로 함수 안에서 우선순위 큐를 이용하는 방식으로 대체했기 때문

  ```python
  import heapq
  import sys
  input = sys.stdin.readline
  INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

  # 노드의 개수, 간선의 개수를 입력받기
  n, m = map(int, input().split())
  # 시작 노드 번호를 입력받기
  start = int(input())
  # 각 노드에 연결되어 있는 노드에 대한 정보를 담는 리스트를 만들기
  graph = [[] for i in range(n + 1)]
  # 최단 거리 테이블을 모두 무한으로 초기화
  distance = [INF] * (n + 1)

  # 모든 간선 정보를 입력받기
  for _ in range(m):
      a, b, c = map(int, input().split())
      # a번 노드에서 b번 노드로 가는 비용이 c라는 의미
      graph[a].append((b, c))

  def dijkstra(start):
      q = []
      # 시작 노드로 가기 위한 최단 경로는 0으로 설정하여, 큐에 삽입
      heapq.heappush(q, (0, start))
      distance[start] = 0
      while q: # 큐가 비어있지 않다면
          # 가장 최단 거리가 짧은 노드에 대한 정보 꺼내기
          dist, now = heapq.heappop(q)
          # 현재 노드가 이미 처리된 적이 있는 노드라면 무시
          if distance[now] < dist:
              continue
          # 현재 노드와 연결된 다른 인접한 노드들을 확인
          for i in graph[now]:
              cost = dist + i[1]
              # 현재 노드를 거쳐서, 다른 노드로 이동하는 거리가 더 짧은 경우
              if cost < distance[i[0]]:
                  distance[i[0]] = cost
                  heapq.heappush(q, (cost, i[0]))

  # 다익스트라 알고리즘을 수행
  dijkstra(start)

  # 모든 노드로 가기 위한 최단 거리를 출력
  for i in range(1, n + 1):
      # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
      if distance[i] == INF:
          print("INFINITY")
      # 도달할 수 있는 경우 거리를 출력
      else:
          print(distance[i])
  ```

- 시간 복잡도
  - 개선된 다익스트라 알고리즘은 O(ElogV)의 시간 복잡도를 가짐
  - 노드를 하나씩 꺼내 검사하는 반복문(while문)은 노드의 개수 V 이상의 횟수로는 처리되지 않음
  - 또한 V번 반복될 때마다 각자 자신과 연결된 간선들을 모두 확인한다.
  - 따라서 '현재 우선순위 큐에서 꺼낸 노드와 연결된 다른 노드들을 확인'하는 총횟수는 최대 간선의 개수(E)만큼 연산이 수행될 수 있음
  - 간단하게 생각하면 최대 E개의 간선 데이터를 힙에 넣었다가 모두 빼내는 연산과 동일하므로 O(ElogE)라고 볼 수 있음

# 플로이드 워셜 알고리즘

- 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야 하는 경우에 사용할 수 있는 알고리즘
- 노드의 개수가 N개 일 때 알고리즘상으로 N번의 단계를 수행하며, 단계마다 O(N^2)의 연산을 통해 '현재 노드를 거쳐 가는' 모든 경로를 고려함
- 따라서 플로이드 워셜 알고리즘의 총 시간 복잡도는 O(N^3)이다.
- 다익스트라 알고리즘에서는 출발 노드가 1개이므로 다른 모든 노드로 가는 최단 거리를 저장하기 위한 1차원 리스트를 이용했지만, 플로이드 워셜 알고리즘에서는 단계마다 방문하고 있는 노드를 기준으로 2차원 리스트에 최단 거리 정보를 저장한다는 특징이 있다.
- 또한 다익스트라 알고리즘은 그리디 알고리즘인데 반해, 플로이드 워셜 알고리즘은 다이나믹 프로그래밍에 속함
  - 노드의 개수가 N이라고 할 때, N번 만큼의 단계를 반복하며 '점화식에 맞게' 2차원 리스트를 갱신하기 때문
- 점화식: Dab = min(Dab, Dak + Dkb)
  - a에서 b로 가는 최소 비용은 a에서 b로 가는 비용과 a에서 k를 거쳐 b로 가는 비용 중에서 최소 비용을 가진 값으로 갱신한다는 의미
- 코드

  ```python
  INF = int(1e9) # 무한을 의미하는 값으로 10억을 설정

  # 노드의 개수 및 간선의 개수를 입력받기
  n = int(input())
  m = int(input())
  # 2차원 리스트(그래프 표현)를 만들고, 모든 값을 무한으로 초기화
  graph = [[INF] * (n + 1) for _ in range(n + 1)]

  # 자기 자신에서 자기 자신으로 가는 비용은 0으로 초기화
  for a in range(1, n + 1):
      for b in range(1, n + 1):
          if a == b:
              graph[a][b] = 0

  # 각 간선에 대한 정보를 입력받아, 그 값으로 초기화
  for _ in range(m):
      # A에서 B로 가는 비용은 C라고 설정
      a, b, c = map(int, input().split())
      graph[a][b] = c

  # 점화식에 따라 플로이드 워셜 알고리즘을 수행
  for k in range(1, n + 1):
      for a in range(1, n + 1):
          for b in range(1, n + 1):
              graph[a][b] = min(graph[a][b], graph[a][k] + graph[k][b])

  # 수행된 결과를 출력
  for a in range(1, n + 1):
      for b in range(1, n + 1):
          # 도달할 수 없는 경우, 무한(INFINITY)이라고 출력
          if graph[a][b] == INF:
              print("INFINITY", end=" ")
          # 도달할 수 있는 경우 거리를 출력
          else:
              print(graph[a][b], end=" ")
      print()
  ```

  > 입력

```plaintext
4
7
1 2 4
1 4 6
2 1 3
2 3 7
3 1 5
3 4 4
4 3 2
```

> 출력

```plaintext
0 4 8 6
3 0 7 9
5 9 0 4
7 11 2 0
```
