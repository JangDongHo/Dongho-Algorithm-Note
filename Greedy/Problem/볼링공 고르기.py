'''
난이도: 1
목표 시간: 30분
시간 제한: 1초
메모리 제한: 128MB

성공 여부: 성공
풀이 시간: 10분
'''
'''
접근 방법
- 2중 반복문을 이용해서 브루트포스 방식을 이용해 모든 경우의 수를 체크했다.
- 만약 n의 개수가 컸다면 다른 방법을 이용해야겠지만, n의 범위가 1,000이하 였기에 2중 반복문을 사용해도 무방하겠다고 생각했다.
'''
### 내가 푼 코드

n, m = map(int, input().split())
ball_list = list(map(int, input().split()))
result = 0

for i in range(n - 1):
  for j in range(i + 1, n):
    if ball_list[i] != ball_list[j]:
      result += 1

print(result)

### 책 코드
'''
개선 방법
- 이 문제를 효과적으로 해결하기 위해서는, 먼저 무게마다 볼링공이 몇 개 있는지를 계산해야 한다.
  - 무게가 1인 볼링공: 1개
  - 무게가 2인 볼링공: 2개
  - 무게가 3인 볼링공: 2개
- 이때 A가 특정한 무게의 볼링공을 선택했을 때, 이어서 B가 볼링공을 선택하는 경우를 차례대로 계산하여 문제를 해결할 수 있다.

- A가 무게가 1인 공을 선택할 때의 경우의 수
  - 무게가 1인 공의 개수 * B가 선택할 수 있는 경우의 수 = 1 * 4 = 4
- A가 무게가 2인 공을 선택할 때의 경우의 수
  - 무게가 2인 공의 개수 * B가 선택할 수 있는 경우의 수 = 2 * 2 = 4
- A가 무게가 3인 공을 선택할 때의 경우의 수
  - 무게가 3인 공의 개수 * B가 선택할 수 있는 경우의 수 = 2 * 0 = 0

따라서 가능한 경우의 수는 총 8가지
'''
n, m = map(int, input().split())
data = list(map(int, input().split()))

# 1부터 10까지의 무게를 담을 수 있는 리스트
array = [0] * 11

for x in data:
  # 각 무게에 해당하는 볼링공의 개수 카운트
  array[x] += 1

result = 0
# 1부터 m까지의 각 무게에 대하여 처리
for i in range(1, m + 1):
  n -= array[i]  # 무게가 i인 볼링공의 개수(A가 선택할 수 있는 개수) 제외
  result += array[i] * n  # B가 선택하는 경우의 수와 곱해주기

print(result)
