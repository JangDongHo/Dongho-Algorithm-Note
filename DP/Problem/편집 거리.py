'''
난이도: 1.5
목표 시간: 30분
시간 제한: 2초
메모리 제한: 128MB

성공 여부: 성공
풀이 시간: 18분
'''
'''
접근 방식
- 이 문제는 최소 편집 거리를 담을 2차원 테이블을 초기화한 뒤에, 최소 편집거리를 계산해 테이블에 저장하는 과정으로 문제를 해결할 수 있다.
  1. 행과 열에 해당하는 문자가 서로 같다면, 왼쪽 위에 해당하는 수를 그대로 대입
  2. 행과 열에 해당하는 문자가 서로 다르다면, 왼쪽(삽입), 위쪽(삭제), 왼쪽 위(교체)에 해당하는 수 중에서 가장 작은 수에 1을 더해 대입
- 이를 점화식으로 바꾸면 다음과 같다.
  1. 두 문자가 같은 경우: dp[i][j] = dp[i-1][j-1]
  2. 두 문자가 다른 경우: dp[i][j] = 1 + min(dp[i][j-1], dp[i-1][j], dp[i-1][j-1])
'''

### 내가 푼 코드

word1 = input()
word2 = input()
n = len(word1)
m = len(word2)

# 각 문자열의 길이 + 1만큼 2차원 배열(DP) 생성
dp = [[0] * (n + 1) for _ in range(m + 1)]

# DP 초기 세팅
for i in range(n + 1):
  dp[0][i] = i
for i in range(m + 1):
  dp[i][0] = i

# Edit Distance 알고리즘
for i in range(1, m + 1):
  for j in range(1, n + 1):
    if word1[j - 1] == word2[i - 1]:
      dp[i][j] = dp[i - 1][j - 1]
    else:
      dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1

print(dp[-1][-1])
